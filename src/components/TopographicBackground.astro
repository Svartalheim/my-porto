---
/**
 * Usage:
 * <TopographicBackground class="fixed inset-0 -z-10" />
 */
const { class: className = "" } = Astro.props;
const canvasId = "topo-canvas"; // you can change / pass as prop if needed
---

<div class={`topo-wrapper ${className}`}>
  <canvas id={canvasId}></canvas>
</div>

<script>
  if (typeof window !== "undefined") {
    const initTopo = () => {
      const canvas = document.getElementById("topo-canvas");
      if (!canvas) {
        console.warn("[TopographicBackground] canvas element not found");
        return;
      }

      const gl = canvas.getContext("webgl", { antialias: true });
      if (!gl) {
        console.warn("WebGL not supported");
        return;
      }

      // ------------- WebGL setup (same as before) -------------
      const vertexSrc = `
        attribute vec2 a_position;
        varying vec2 v_uv;

        void main() {
          v_uv = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      const fragmentSrc = `
        precision highp float;

        varying vec2 v_uv;

        uniform vec2  u_resolution;
        uniform float u_time;
        uniform vec4  u_bgColor;
        uniform vec4  u_lineColor;
        uniform vec2  u_freq1;
        uniform vec2  u_freq2;
        uniform vec2  u_speed;
        uniform float u_lineThickness;
        uniform float u_lineSpacing;

        float hash(vec2 p) {
          p = vec2(dot(p, vec2(127.1, 311.7)),
                   dot(p, vec2(269.5, 183.3)));
          return -1.0 + 2.0 * fract(sin(p.x) * 43758.5453123 + sin(p.y) * 43758.5453123);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);

          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));

          vec2 u = f * f * (3.0 - 2.0 * f);

          return mix(a, b, u.x) +
                 (c - a) * u.y * (1.0 - u.x) +
                 (d - b) * u.x * u.y;
        }

        void main() {
          vec2 uv = v_uv;
          vec2 aspect = vec2(u_resolution.x / u_resolution.y, 1.0);
          vec2 p = (uv - 0.5) * aspect;

          // Create a time-varying offset vector using noise for random movement
          vec2 time_offset = vec2(
            noise(p + u_time * 0.2),
            noise(p + u_time * 0.2 + vec2(5.2, 1.3))
          );

          // Apply the randomized offset instead of a uniform directional speed
          p += time_offset * 0.4;

          float h =
            sin(p.x * u_freq1.x) +
            sin(p.y * u_freq1.y) +
            sin((p.x + p.y) * u_freq2.x) * 0.7 +
            noise(p * u_freq2.y) * 0.6;

          float dynamicThickness = u_lineThickness;
          float dynamicSpacing = u_lineSpacing * (0.5 + 0.1 * cos(u_time * 0.9));

          float scaled = h * dynamicSpacing;

          float f = abs(fract(scaled) - 0.5);

          float line = smoothstep(
            dynamicThickness,
            0.0,
            f
          );

          vec3 color = mix(u_bgColor.rgb, u_lineColor.rgb, line);

          gl_FragColor = vec4(color, 1.0);
        }
      `;

      function createShader(gl, type, src) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      function createProgram(gl, vsSrc, fsSrc) {
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);

        if (!vs || !fs) {
          return null;
        }

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(program));
          gl.deleteProgram(program);
          return null;
        }
        return program;
      }

      const program = createProgram(gl, vertexSrc, fragmentSrc);
      if (!program) return;
      gl.useProgram(program);

      const quad = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
          -1, -1,
          1, -1,
          -1,  1,
          -1,  1,
          1, -1,
          1,  1
        ]),
        gl.STATIC_DRAW
      );

      const aPosLoc = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(aPosLoc);
      gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);

      const uResolution = gl.getUniformLocation(program, "u_resolution");
      const uTime       = gl.getUniformLocation(program, "u_time");
      const uBgColor    = gl.getUniformLocation(program, "u_bgColor");
      const uLineColor  = gl.getUniformLocation(program, "u_lineColor");
      const uFreq1      = gl.getUniformLocation(program, "u_freq1");
      const uFreq2      = gl.getUniformLocation(program, "u_freq2");
      const uSpeed      = gl.getUniformLocation(program, "u_speed");
      const uLineThickness = gl.getUniformLocation(program, "u_lineThickness");
      const uLineSpacing   = gl.getUniformLocation(program, "u_lineSpacing");

      const rand = Math.random;
      const sign = () => (rand() > 0.5 ? 1 : -1);

      const params = {
        freq1: [2.0 + rand() * 3.0, 2.0 + rand() * 3.0],
        freq2: [1.0 + rand() * 2.0, 2.0 + rand() * 3.0],
        speed: [sign() * (0.3 + rand()), sign() * (0.1 + rand() * 0.5)],
        lineThickness: 0.06 + rand() * 0.03,
        lineSpacing:   3.0 + rand() * 2.5,
        bgColor:   [0.97, 0.97, 0.97, 1.0],
        lineColor: [0.82, 0.82, 0.82, 1.0],
      };

      function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(uResolution, canvas.width, canvas.height);
      }

      window.addEventListener("resize", resize);
      resize();

      gl.uniform4fv(uBgColor, new Float32Array(params.bgColor));
      gl.uniform4fv(uLineColor, new Float32Array(params.lineColor));
      gl.uniform2f(uFreq1, params.freq1[0], params.freq1[1]);
      gl.uniform2f(uFreq2, params.freq2[0], params.freq2[1]);
      gl.uniform2f(uSpeed, params.speed[0], params.speed[1]);
      gl.uniform1f(uLineThickness, params.lineThickness);
      gl.uniform1f(uLineSpacing, params.lineSpacing);

      const start = performance.now();
      function render() {
        const t = (performance.now() - start) / 1000;
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform1f(uTime, t);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
      }
      render();
    };

    // Make sure DOM is ready *before* we query the canvas
    if (document.readyState === "complete" || document.readyState === "interactive") {
      initTopo();
    } else {
      window.addEventListener("DOMContentLoaded", initTopo, { once: true });
    }
  }
</script>

<style>
  .topo-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  #topo-canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>