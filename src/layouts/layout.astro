---
import '../styles/global.css';
import { ClientRouter } from 'astro:transitions';
import Navigation from '../components/Navigation.astro';
import BottomBar from '../components/BottomBar.astro';
// Define props for this layout. Extend as needed.
export interface Props {
  name?: string; // page identifier / slug
  title?: string; // optional <title> override
}
const { name = 'page', title } = Astro.props as Props;
---

<html lang='en'>
  <head>
    <ClientRouter />
    <meta charset='utf-8' />
    <link rel='icon' type='image/svg+xml' href='/favicon.svg' />
    <meta name='viewport' content='width=device-width' />
    <meta name='generator' content={Astro.generator} />
    <title>{title ? title : name ? `${name} | Astro` : 'Astro'}</title>

    <link rel='preconnect' href='https://fonts.googleapis.com' />
    <link rel='preconnect' href='https://fonts.gstatic.com' crossorigin />

    <style is:global>
      /* Prevent horizontal scrolling during transitions */
      html {
        overflow-x: hidden;
      }
      #page {
        --blur-p: 0; /* 0..1 */
        --blr-m: var(--grid-margin);
        --blr-s-min: 0.0294; /* unitless */
        --blr-s-max: 0.0474; /* unitless */
        --blr-s: var(--blr-s-min); /* start at min */
        will-change: transform;
  /* Pivot scale animations around a dynamic point */
  transform-origin: var(--origin-x, 50%) var(--origin-y, 50%);
        /* transition-duration needs a time value, not a JS-like expr */
        transition-duration: var(--MENU_DURATION, 0.2s);
        transition-property: transform, opacity;
        transition-timing-function: linear;
      }

      /* Your margin tweak stays */
      @media (max-width: 743px) {
        #page {
          --blr-m: 10px;
        }
      }

      /* Step up the unitless scale factor as the viewport shrinks */
      @media (max-width: 1200px) {
        #page {
          --blr-s: 0.034;
        }
      }
      @media (max-width: 900px) {
        #page {
          --blr-s: 0.04;
        }
      }
      @media (max-width: 600px) {
        #page {
          --blr-s: var(--blr-s-max);
        }
      }

      /* Use the unitless value safely in scale() */
      #page[data-blurred='true'] {
        transform: scale(calc(1 - (var(--blr-s) * var(--blur-p))));
        opacity: calc(1 - 0.333 * var(--blur-p));
      }
      /* CSS variables for consistent timing */
      :root {
        --transition-duration: 0.4s;
        --transition-timing: cubic-bezier(0.4, 0, 0.2, 1);
        --transition-delay: 0s;
      }

      /* Only apply transitions when View Transitions API is supported */
      .view-transition-enabled {
        view-transition-name: none;
      }

      .view-transition-enabled .page-container {
        view-transition-name: page;
        position: relative;
        width: 100%;
        min-height: 100vh;
      }

      /* Add this class during animation to prevent unwanted scrolling */
      .animating {
        overflow: hidden;
      }

      /* Control the animations with strict timing */
      ::view-transition-old(page) {
        animation: slide-out-down var(--transition-duration)
          var(--transition-timing) var(--transition-delay) both;
        z-index: -100;
        transform-origin: top left;
      }

      ::view-transition-new(page) {
        animation: slide-in-bottom var(--transition-duration)
          var(--transition-timing) var(--transition-delay) both;
        z-index: 100;
      }

      /* Main page transition keyframes */
      @keyframes slide-in-bottom {
        from {
          transform: translateY(75%);
          opacity: 1;
        }
        to {
          transform: translateY(0%);
          opacity: 1;
        }
      }

      @keyframes slide-out-down {
        from {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
        to {
          transform: translate(1%, 1%) rotate(1deg) scale(0.95);
          opacity: 0.3;
        }
      }

      /* Force stacking contexts for transition elements */
      ::view-transition-group(root),
      ::view-transition-old(root),
      ::view-transition-new(root) {
        animation-duration: var(--transition-duration);
      }

      /* Ensure content inside the transition is visible */
      ::view-transition-image-pair(page) {
        isolation: auto;
      }

      ::view-transition-old(page),
      ::view-transition-new(page) {
        mix-blend-mode: normal;
      }

      /* Force hardware acceleration for smoother transitions */
      .view-transition-enabled .page-container {
        transform: translateZ(0);
        backface-visibility: hidden;
        will-change: transform;
      }

      /* Logo specific transitions - keeping your original logo animations */
      ::view-transition-old(logo) {
        animation: scaleOut 0.3s ease-in;
      }

      ::view-transition-new(logo) {
        animation: scaleIn 0.5s ease-out;
      }

      @keyframes scaleIn {
        from {
          transform: scale(0.8);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes scaleOut {
        from {
          transform: scale(1);
          opacity: 1;
        }
        to {
          transform: scale(1.1);
          opacity: 0;
        }
      }

      /* Smooth transitions for all elements */
      * {
        transition-property: transform, opacity, scale;
        transition-timing-function: var(--transition-timing);
      }

      /* Disable transitions during page load */
      .page-loading * {
        transition: none !important;
      }

      /* Development indicator styles */
      .dev-indicator {
        position: fixed;
        top: 1rem;
        right: 1rem;
        padding: 0.5rem 0.75rem;
        font-size: 0.75rem;
        font-family: monospace;
        border-radius: 0.25rem;
        opacity: 0.7;
        z-index: 50;
        color: white;
      }

      .dev-indicator.supported {
        background-color: #0c7040;
      }

      .dev-indicator.not-supported {
        background-color: #703030;
      }
    </style>
  </head>
  <body class='bg-primary text-primary'>
    <!-- <Navigation /> -->
    <div
      data-slug={name}
      class='page-container bg-background h-full'
      transition:name='page'
      id='page'
    >
      <slot />
      <div
        data-blur-mask
        inert
        aria-hidden='true'
        class='absolute w-full h-full top-0 left-0'
      >
      </div>
    </div>
    <!-- Bottom navigation component -->
    <BottomBar />

    <!-- Development indicator for View Transitions support (only in dev) -->
    <div id='dev-indicator' class='dev-indicator' style='display: none;'>
      View Transitions: <span id='transition-status'>Checking...</span>
    </div>

    <script>
      // Check for View Transitions API support and enable features
      function initViewTransitions() {
        const hasViewTransition = 'startViewTransition' in document;
        const devIndicator = document.getElementById('dev-indicator');
        const statusSpan = document.getElementById('transition-status');

        if (hasViewTransition) {
          document.documentElement.classList.add('view-transition-enabled');

          if (devIndicator && statusSpan) {
            devIndicator.classList.add('supported');
            statusSpan.textContent = 'Enabled';
          }
        } else {
          console.warn('View Transitions API is NOT supported in this browser');

          if (devIndicator && statusSpan) {
            devIndicator.classList.add('not-supported');
            statusSpan.textContent = 'Not Supported';
          }

          // Show dev indicator only in development
          if (devIndicator && import.meta.env.DEV) {
            devIndicator.style.display = 'block';
          }

          // Add animating class during transitions to prevent scrolling
          if (hasViewTransition) {
            document.addEventListener('astro:before-preparation', () => {
              document.documentElement.classList.add('animating');
            });

            document.addEventListener('astro:after-swap', () => {
              document.documentElement.classList.remove('animating');
            });
          }
        }
      }
      // Initialize on page load
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initViewTransitions);
      } else {
        initViewTransitions();
      }

      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        document.documentElement.classList.remove('view-transition-enabled');
        document.documentElement.classList.remove('animating');
      });

      // ---- Dynamic transform-origin helpers ----
      // Contract:
      // - Uses #page as the element that scales.
      // - Default origin is 50% X and Y derived from current viewport (baseline 8% from top).
      // - Clicking a trigger can set the origin to the click position within #page.

      function getPageEl() {
        return document.getElementById('page');
      }

      // Compute an origin based on the current viewport window with a baseline offset
      // of baselinePct (e.g., 8%) from the top of the viewport.
      function computeOriginFromViewport(baselinePct = 8) {
        const page = getPageEl();
        if (!page) return;

        // Absolute geometry of #page and viewport
        const pageRect = page.getBoundingClientRect();
        const pageTopAbs = pageRect.top + window.scrollY;
        const pageHeight = Math.max(page.scrollHeight, page.clientHeight);
        const viewportBottomAbs = window.scrollY + window.innerHeight;
        const pageBottomAbs = pageTopAbs + pageHeight;

        // If we're effectively at the bottom of the page, pin origin to the bottom
        const nearBottomThreshold = 1; // px
        let yPct;
        if (viewportBottomAbs >= pageBottomAbs - nearBottomThreshold) {
          yPct = 100;
        } else {
          // Otherwise, anchor baselinePct% from the top of the current viewport
          const yAbs = window.scrollY + window.innerHeight * (baselinePct / 100);
          const yWithinPage = Math.max(0, Math.min(yAbs - pageTopAbs, pageHeight));
          yPct = (yWithinPage / pageHeight) * 100;
        }

        page.style.setProperty('--origin-x', '50%');
        page.style.setProperty('--origin-y', `${yPct}%`);
      }

      // Set origin from a click/press event so the scale pivots around the interacted spot.
  function setOriginFromEvent(e: MouseEvent) {
        const page = getPageEl();
        if (!page || !e) return;
        const rect = page.getBoundingClientRect();
        const xAbs = e.clientX + window.scrollX;
        const yAbs = e.clientY + window.scrollY;
        const pageLeftAbs = rect.left + window.scrollX;
        const pageTopAbs = rect.top + window.scrollY;
        const xWithin = xAbs - pageLeftAbs;
        const yWithin = yAbs - pageTopAbs;
        const xPct = (xWithin / rect.width) * 100;
        const pageHeight = Math.max(page.scrollHeight, page.clientHeight);
        const yPct = (yWithin / pageHeight) * 100;

        page.style.setProperty('--origin-x', `${xPct}%`);
        page.style.setProperty('--origin-y', `${yPct}%`);
      }

      // Public helper if you want to call manually from components
  (window as any).__setScaleOrigin = function (xPct?: number, yPct?: number) {
        const page = getPageEl();
        if (!page) return;
        if (typeof xPct === 'number') page.style.setProperty('--origin-x', `${xPct}%`);
        if (typeof yPct === 'number') page.style.setProperty('--origin-y', `${yPct+8}%`);
      };

      // Keep origin tied to the current viewport as the user scrolls.
      let rafId: number | null = null;
      function onScroll() {
        if (rafId !== null) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => {
          computeOriginFromViewport(8);
          rafId = null;
        });
      }
      window.addEventListener('scroll', onScroll, { passive: true });

      // Delegate clicks from elements that open/expand content to pivot around click point.
      // Mark triggers with any of these attributes to opt-in.
      document.addEventListener(
        'click',
        (e: MouseEvent) => {
          let trigger: Element | null = null;
          const t = e.target;
          if (t instanceof Element) {
            trigger = t.closest('[data-origin-anchor], [data-expand], [data-open]');
          }
          if (trigger) setOriginFromEvent(e);
        },
        { capture: true }
      );

      // Initialize once and also after Astro swaps content.
      function initOrigin() {
        computeOriginFromViewport(8);
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initOrigin);
      } else {
        initOrigin();
      }

      document.addEventListener('astro:after-swap', initOrigin);
    </script>
  </body>
</html>
