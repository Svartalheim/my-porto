---
import { ClientRouter } from 'astro:transitions';
import BottomBar from '../components/BottomBar.astro';
import Footer from '../layouts/Footer.astro';
import '../styles/global.css';
// Define props for this layout. Extend as needed.
export interface Props {
  name?: string; // page identifier / slug
  title?: string; // optional <title> override
}
const { name = 'page', title } = Astro.props as Props;
---

<html lang='en'>
  <head>
    <ClientRouter />
    <meta charset='utf-8' />
    <link rel='icon' type='image/svg+xml' href='/favicon.svg' />
    <meta name='viewport' content='width=device-width' />
    <meta name='generator' content={Astro.generator} />
    <title>{title ? title : name ? `${name} | Astro` : 'Astro'}</title>

    <link rel='preconnect' href='https://fonts.googleapis.com' />
    <link rel='preconnect' href='https://fonts.gstatic.com' crossorigin />

    <style is:global>
      /* Prevent horizontal scrolling during transitions */
      html {
        overflow-x: hidden;
      }
      #page {
        --blur-p: 0; /* 0..1 */
        --blr-m: var(--grid-margin);
        --blr-s-min: 0.032; /* unitless (slightly larger on wide screens) */
        --blr-s-max: 0.0474; /* unitless */
        --blr-s: var(--blr-s-min); /* start at min */
        position: relative; /* anchor stacking for overlays */
        z-index: 1; /* keep content above fixed overlays */
        will-change: transform;
        /* Pivot scale animations around a dynamic point */
        transform-origin: var(--origin-x, 50%) var(--origin-y, 50%);
        /* transition-duration needs a time value, not a JS-like expr */
        transition-duration: var(--MENU_DURATION, 0.2s);
        transition-property: transform, opacity;
        transition-timing-function: linear;
      }

      /* Your margin tweak stays */
      @media (max-width: 743px) {
        #page {
          --blr-m: 10px;
        }
      }

      /* Step up the unitless scale factor as the viewport shrinks */
      @media (max-width: 1200px) {
        #page {
          --blr-s: 0.037; /* slightly larger */
        }
      }
      @media (max-width: 900px) {
        #page {
          --blr-s: 0.0594; /* slightly larger */
        }
      }
      @media (max-width: 600px) {
        #page {
          --blr-s: var(--blr-s-max);
        }
      }

      /* Only scale the page content, not overlays */
      #page .page-content {
        will-change: transform;
        transform-origin: var(--origin-x, 50%) var(--origin-y, 50%);
        transition-duration: var(--MENU_DURATION, 0.2s);
        transition-property: transform, opacity;
        transition-timing-function: linear;
      }
      #page[data-blurred='true'] .page-content {
        transform: scale(calc(1 - (var(--blr-s) * var(--blur-p))));
        /* opacity: calc(1 - 0.2333 * var(--blur-p)); */
      }
      #page [data-blur-mask] > div {
        position: sticky;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
      }

      #page[data-blurred='true']::after {
        content: '';
        position: absolute;
        left: 0;
        /* right: 0; */
        height: 20vh;
        overflow: hidden;
        background-color: red; /* match #page bg */
        pointer-events: none; /* don't block clicks */
        bottom: -10vh;
      }

      #page [data-blur-mask] > div > div:first-child:before {
        left: 0;
        transform-origin: left;
      }
      #page [data-blur-mask] > div > div:first-child:after {
        right: 0;
        transform-origin: right;
      }
      #page [data-blur-mask] > div > div:after,
      #page [data-blur-mask] > div > div:before {
        content: '';
        position: absolute;
        background-color: #000;
        will-change: transform;
      }
      #page [data-blur-mask] > div > div:first-child:after,
      #page [data-blur-mask] > div > div:first-child:before {
        width: var(--blr-m);
        height: 100%;
        top: 0;
        transform: scaleX(var(--blur-p));
      }
      #page [data-blur-mask] > div > div:nth-child(2):before {
        top: 0;
        transform-origin: top;
      }

      /* #page [data-blur-mask]>div>div:nth-child(2):after, */
      #page [data-blur-mask] > div > div:nth-child(2):before {
        width: 100%;
        height: var(--blr-m);
        left: 0;
        transform: scaleY(var(--blur-p));
      }

      #page [data-blur-mask] > div > div:nth-child(3):before {
        left: var(--blr-m);
        border-top-left-radius: 20px;
        transform-origin: 0% 0%;
        transform: translate(
            calc((var(--blur-p) - 1) * var(--blr-m)),
            calc((var(--blur-p) - 1) * var(--blr-m))
          )
          scale(var(--blur-p));
      }

      #page [data-blur-mask] > div > div:nth-child(3):after {
        right: var(--blr-m);
        border-top-right-radius: 20px;
        transform-origin: 100% 0%;
        transform: translate(
            calc(-1 * (var(--blur-p) - 1) * var(--blr-m)),
            calc((var(--blur-p) - 1) * var(--blr-m))
          )
          scale(var(--blur-p));
      }

      #page [data-blur-mask] > div > div:nth-child(3):after,
      #page [data-blur-mask] > div > div:nth-child(3):before {
        top: var(--blr-m);
        width: var(--page-border-radius);
        height: calc(2 * var(--page-border-radius));
        box-shadow: 0 calc(-1 * var(--page-border-radius)) 0 0 #000;
        background-color: rgba(0, 0, 0, 0);
      }

      .page-container {
        view-transition-name: page;
        position: relative;
        width: 100%;
        min-height: 100vh;
      }

      ::view-transition-old(page) {
        animation: slide-out-down var(--transition-duration)
          var(--transition-timing) var(--transition-delay) both;
        z-index: -100;
        transform-origin: top left;
      }

      ::view-transition-group(page) {
        z-index: -10 !important;
      }

      ::view-transition-new(page) {
        background-color: #000 !important;
        animation: slide-in-bottom var(--transition-duration)
          var(--transition-timing) var(--transition-delay) both;
        animation-duration: 0.3s;
        z-index: -100;
      }

      /* Main page transition keyframes */
      @keyframes slide-in-bottom {
        from {
          transform: translateY(75%);
          opacity: 1;
        }
        to {
          transform: translateY(0%);
          opacity: 1;
        }
      }

      @keyframes slide-out-down {
        from {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
        to {
          transform: translate(1%, 1%) rotate(1deg) scale(0.95);
          opacity: 0.3;
        }
      }

      /* Force stacking contexts for transition elements */
      ::view-transition-group(root),
      ::view-transition-old(root),
      ::view-transition-new(root) {
        animation-duration: var(--transition-duration);
        z-index: -100;
      }

      ::view-transition-old(page),
      ::view-transition-new(page) {
        /* mix-blend-mode: normal; */
      }

      /* Force hardware acceleration for smoother transitions */
      .view-transition-enabled .page-container {
        transform: translateZ(0);
        backface-visibility: hidden;
        will-change: transform;
      }

      /* Smooth transitions for all elements */
      /* Limit global transitions to page content so chrome like BottomBar doesn't animate */
      .page-content * {
        transition-property: transform, opacity, scale;
        transition-timing-function: var(--transition-timing);
      }
    </style>
  </head>
  <body class=''>
    <BottomBar transition:persist transition:animate='none' />

    <div class='bg-black'>
      <div
        data-slug={name}
        class='page-container bg-background relative h-full max-w-[var(--100vw)]'
        transition:name='page'
        id='page'
      >
        <div class='page-content'>
          <slot />
          <Footer />
        </div>
        <div
          data-blur-mask
          inert
          aria-hidden='true'
          class='absolute w-full h-full top-0 left-0 pointer-events-none'
        >
          <div>
            <div id='#overlay-left-right'></div>
            <div id='#overlay-top'></div>
            <div id='#overlay-corner'></div>
          </div>
          <span></span>
        </div>
      </div>
    </div>

    <!-- Development indicator for View Transitions support (only in dev) -->
    <!-- <div id="dev-indicator" class="dev-indicator">
      View Transitions: <span id="transition-status">Checking...</span>
    </div> -->
  </body>
</html>
<script>
  import Lenis from 'lenis';

  const lenis = new Lenis({
    autoRaf: true,
  });
  // expose for transition handlers
  (window as any).__lenis = lenis;
</script>

<script>
  // ---- Dynamic transform-origin helpers ----
  // Element we scale
  function getPageEl() {
    return document.getElementById('page');
  }

  // tiny padding so the pivot isn't exactly on the edge (looks nicer)
  const EDGE_PAD_PCT = 4; // e.g. 8% from top/bottom
  const lerp = (a: number, b: number, t: number) => a + (b - a) * t;
  const clamp = (v: number, lo: number, hi: number) =>
    Math.min(hi, Math.max(lo, v));

  /**
   * Compute origin based on scroll progress:
   * - at the very top → pivot near top (EDGE_PAD_PCT%)
   * - at the very bottom → pivot near bottom (100 - EDGE_PAD_PCT%)
   * - in between → linear interpolation
   */
  function computeOriginFromViewport(edgePadPct = EDGE_PAD_PCT) {
    const page = getPageEl();
    if (!page) return;

    const rect = page.getBoundingClientRect();
    const pageTopAbs = rect.top + window.scrollY;

    // total content height for the page element
    const pageHeight = Math.max(page.scrollHeight, page.clientHeight);
    const viewportH = window.innerHeight;

    // how much we can actually scroll inside #page
    const scrollable = Math.max(pageHeight - viewportH, 0);

    // scrollTop measured relative to the top of #page
    const scrollInPage = clamp(window.scrollY - pageTopAbs, 0, scrollable);

    // progress (0 at top, 1 at bottom). If not scrollable, use 0.5 (center).
    const p = scrollable > 0 ? scrollInPage / scrollable : 0.5;

    // map progress to a % along the element height with padding at edges
    const yPct = lerp(edgePadPct, 100 - edgePadPct, p);

    page.style.setProperty('--origin-x', '50%');
    page.style.setProperty('--origin-y', `${yPct}%`);
  }

  /** Pivot around the click point (keeps your API the same) */
  function setOriginFromEvent(e: MouseEvent) {
    const page = getPageEl();
    if (!page || !e) return;
    const rect = page.getBoundingClientRect();
    const xWithin = e.clientX - rect.left;
    const yWithin = e.clientY - rect.top;
    const xPct = (xWithin / rect.width) * 100;

    // Use full content height (scrollHeight) so long pages map correctly
    const h = Math.max(page.scrollHeight, page.clientHeight);
    const yPct =
      ((yWithin + window.scrollY - (rect.top + window.scrollY)) / h) * 100;

    page.style.setProperty('--origin-x', `${clamp(xPct, 0, 100)}%`);
    page.style.setProperty('--origin-y', `${clamp(yPct, 0, 100)}%`);
  }

  // Public helper (optional baseline bump on Y)
  (window as any).__setScaleOrigin = function (xPct?: number, yPct?: number) {
    const page = getPageEl();
    if (!page) return;
    if (typeof xPct === 'number')
      page.style.setProperty('--origin-x', `${clamp(xPct, 0, 100)}%`);
    if (typeof yPct === 'number')
      page.style.setProperty('--origin-y', `${clamp(yPct, 0, 100)}%`);
  };

  // rAF'd listeners so we don’t thrash
  let rafId: number | null = null;
  function scheduleCompute() {
    if (rafId !== null) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => {
      computeOriginFromViewport();
      rafId = null;
    });
  }

  // Keep origin tied to viewport while scrolling/resizing
  window.addEventListener('scroll', scheduleCompute, { passive: true });
  window.addEventListener('resize', scheduleCompute, { passive: true });
  window.addEventListener('orientationchange', scheduleCompute, {
    passive: true,
  });

  // Delegate clicks that should pivot around the interacted point
  document.addEventListener(
    'click',
    (e: MouseEvent) => {
      const t = e.target;
      if (
        t instanceof Element &&
        t.closest('[data-origin-anchor],[data-expand],[data-open]')
      ) {
        setOriginFromEvent(e);
      }
    },
    { capture: true }
  );

  // Init + after Astro swaps
  function initOrigin() {
    computeOriginFromViewport();
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initOrigin);
  } else {
    initOrigin();
  }
  document.addEventListener('astro:after-swap', initOrigin);
</script>
