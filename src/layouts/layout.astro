---
import { ClientRouter } from 'astro:transitions';
import BottomBar from '../components/BottomBar.astro';
import Footer from '../layouts/Footer.astro';
import '../styles/global.css';

export interface Props {
  name?: string;
  title?: string;
}
const { name = 'page', title } = Astro.props as Props;
---

<html lang="en">
  <head>
    <!-- Keep SPA routing; we’ll neutralize native VT below -->
    <ClientRouter />

    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>{title ? title : name ? `${name} | Astro` : 'Astro'}</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- Disable browser View Transitions so ClientRouter won’t animate on its own -->
    <script is:inline>
      if ('startViewTransition' in document) {
        // @ts-ignore
        document.__nativeStartViewTransition__ = document.startViewTransition.bind(document);
        // @ts-ignore
        document.startViewTransition = (cb) => {
          let resolveFinished;
          const finished = new Promise((res) => (resolveFinished = res));
          const ready = Promise.resolve();
          let updateCallbackDone = Promise.resolve();
          try {
            const r = cb?.();
            if (r && typeof r.then === 'function') updateCallbackDone = r;
          } catch (_) {}
          Promise.resolve(updateCallbackDone).then(() => resolveFinished());
          return { finished, ready, updateCallbackDone, skipTransition() {} };
        };
      }
    </script>

    <style is:global>
      /* ====== Your base layout rules kept as-is (trimmed to essentials) ====== */

      html { overflow-x: hidden; }

      .page-container {
        position: relative;
        width: 100%;
        min-height: 100vh;
      }

      #page {
        --blur-p: 0;
        --blr-m: var(--grid-margin);
        --blr-s-min: 0.032;
        --blr-s-max: 0.0474;
        --blr-s: var(--blr-s-min);
        position: relative;
        z-index: 1;
        will-change: transform;
        transform-origin: var(--origin-x, 50%) var(--origin-y, 50%);
        transition-duration: var(--MENU_DURATION, 0.2s);
        transition-property: transform, opacity;
        transition-timing-function: linear;
      }

      @media (max-width: 743px)  { #page { --blr-m: 10px; } }
      @media (max-width: 1200px) { #page { --blr-s: 0.037; } }
      @media (max-width: 900px)  { #page { --blr-s: 0.0594; } }
      @media (max-width: 600px)  { #page { --blr-s: var(--blr-s-max); } }

      #page .page-content {
        will-change: transform;
        transform-origin: var(--origin-x, 50%) var(--origin-y, 50%);
        transition-duration: var(--MENU_DURATION, 0.2s);
        transition-property: transform, opacity;
        transition-timing-function: linear;
      }

      /* ====== Manual transition (no Astro VT) ====== */

      /* Container that holds the frozen old page while it leaves */
      #transition-stack {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 8; /* below your BottomBar (z-10), above the new page */
      }

      .ghost-page {
        position: fixed;
        overflow: clip;
        pointer-events: none;
        will-change: transform, opacity;
        background: var(--background);
      }

      /* OLD page (ghost) leave — your slide-out-down equivalent */
      .ghost-leave {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
      .ghost-leave-active {
        transition:
          transform var(--transition-duration, 400ms) var(--transition-timing, cubic-bezier(0.4, 0, 0.2, 1)),
          opacity   var(--transition-duration, 400ms) linear;
        transform: translate(1%, 1%) rotate(1deg) scale(0.95);
        opacity: 0.3;
      }

      /* NEW page enter — your slide-in-bottom */
      .page-enter {
        transform: translateY(75%);
        opacity: 1;
      }
      .page-enter-active {
        transition: transform var(--transition-duration, 400ms) var(--transition-timing, cubic-bezier(0.4, 0, 0.2, 1));
        transform: translateY(0%);
      }

      @media (prefers-reduced-motion: reduce) {
        .ghost-leave, .page-enter { transform: none !important; opacity: 1 !important; }
        .ghost-leave-active, .page-enter-active { transition: none !important; }
      }

      /* Keep element-level niceties */
      .page-content * {
        transition-property: transform, opacity, scale;
        transition-timing-function: var(--transition-timing);
      }
    </style>
  </head>

  <body class="">
    <!-- Persistent chrome -->
    <BottomBar transition:persist transition:animate="none" />

    <!-- Ghost holder -->
    <div id="transition-stack" aria-hidden="true"></div>

    <!-- Live page (this gets replaced by ClientRouter) -->
    <div
      data-slug={name}
      class="page-container bg-background relative h-full max-w-[var(--100vw)]"
      id="page"
    >
      <div class="page-content">
        <slot />
        <Footer />
      </div>

      <div
        data-blur-mask
        inert
        aria-hidden="true"
        class="absolute w-full h-full top-0 left-0 pointer-events-none"
      >
        <div>
          <div id="#overlay-left-right"></div>
          <div id="#overlay-top"></div>
          <div id="#overlay-corner"></div>
        </div>
        <span></span>
      </div>
    </div>
  </body>
</html>

<!-- Manual transition controller -->
<script is:inline>
  (function () {
    const DUR = 500000; // keep in sync with CSS

    function $(sel, root = document) { return root.querySelector(sel); }

    function stageOldPageLeave(pageEl) {
      if (!pageEl) return;

      // Freeze a visual clone of the current page
      const rect = pageEl.getBoundingClientRect();
      const ghost = pageEl.cloneNode(true);
      ghost.removeAttribute('id');                 // no duplicate #page
      ghost.removeAttribute('data-blurred');       // avoid copying blur state
      ghost.classList.add('ghost-page', 'ghost-leave');

      // Lock its geometry where it currently is
      Object.assign(ghost.style, {
        top: rect.top + 'px',
        left: rect.left + 'px',
        width: rect.width + 'px',
        height: rect.height + 'px'
      });

      let stack = $('#transition-stack');
      if (!stack) {
        stack = document.createElement('div');
        stack.id = 'transition-stack';
        Object.assign(stack.style, { position: 'fixed', inset: 0, pointerEvents: 'none', zIndex: 8 });
        document.body.appendChild(stack);
      }
      stack.appendChild(ghost);

      requestAnimationFrame(() => {
        ghost.classList.add('ghost-leave-active');
      });

      setTimeout(() => ghost.remove(), DUR + 40);
    }

    function animateNewPageEnter() {
      const page = document.getElementById('page');
      if (!page) return;
      page.classList.add('page-enter');
      requestAnimationFrame(() => page.classList.add('page-enter-active'));
      setTimeout(() => {
        page.classList.remove('page-enter', 'page-enter-active');
      }, DUR + 40);
    }

    // Route change hooks:
    // - Before preparation: snapshot & animate OUT the old page
    // - After swap: animate IN the new page
    document.addEventListener('astro:before-preparation', () => {
      const current = document.getElementById('page');
      if (current) stageOldPageLeave(current);
    });

    document.addEventListener('astro:after-swap', () => {
      animateNewPageEnter();
    });

    // No initial animation on first load (by design)
  })();
</script>

<!-- Lenis singleton (paused during swaps) -->
<script is:inline>
  import Lenis from 'lenis';
  (function () {
    if (!(window).__lenis) (window).__lenis = new Lenis({ autoRaf: true });
    const lenis = (window).__lenis;

    document.addEventListener('astro:before-preparation', () => {
      if (lenis && typeof lenis.stop === 'function') lenis.stop();
    });
    document.addEventListener('astro:after-swap', () => {
      if (lenis && typeof lenis.start === 'function') lenis.start();
    });
  })();
</script>

<!-- Your origin helpers (unchanged) -->
<script>
  function getPageEl() { return document.getElementById('page'); }
  const EDGE_PAD_PCT = 4;
  const lerp = (a, b, t) => a + (b - a) * t;
  const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));

  function computeOriginFromViewport(edgePadPct = EDGE_PAD_PCT) {
    const page = getPageEl(); if (!page) return;
    const rect = page.getBoundingClientRect();
    const pageTopAbs = rect.top + window.scrollY;
    const pageHeight = Math.max(page.scrollHeight, page.clientHeight);
    const viewportH = window.innerHeight;
    const scrollable = Math.max(pageHeight - viewportH, 0);
    const scrollInPage = Math.min(scrollable, Math.max(0, window.scrollY - pageTopAbs));
    const p = scrollable > 0 ? scrollInPage / scrollable : 0.5;
    const yPct = lerp(edgePadPct, 100 - edgePadPct, p);
    page.style.setProperty('--origin-x', '50%');
    page.style.setProperty('--origin-y', `${yPct}%`);
  }

  function setOriginFromEvent(e) {
    const page = getPageEl(); if (!page || !e) return;
    const rect = page.getBoundingClientRect();
    const xWithin = e.clientX - rect.left;
    const yWithin = e.clientY - rect.top;
    const xPct = (xWithin / rect.width) * 100;
    const h = Math.max(page.scrollHeight, page.clientHeight);
    const yPct = ((yWithin + window.scrollY - (rect.top + window.scrollY)) / h) * 100;
    page.style.setProperty('--origin-x', `${Math.min(100, Math.max(0, xPct))}%`);
    page.style.setProperty('--origin-y', `${Math.min(100, Math.max(0, yPct))}%`);
  }

  (window).__setScaleOrigin = function (xPct, yPct) {
    const page = getPageEl(); if (!page) return;
    if (typeof xPct === 'number') page.style.setProperty('--origin-x', `${Math.min(100, Math.max(0, xPct))}%`);
    if (typeof yPct === 'number') page.style.setProperty('--origin-y', `${Math.min(100, Math.max(0, yPct))}%`);
  };

  let rafId = null;
  function scheduleCompute() {
    if (rafId !== null) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => { computeOriginFromViewport(); rafId = null; });
  }

  window.addEventListener('scroll', scheduleCompute, { passive: true });
  window.addEventListener('resize', scheduleCompute, { passive: true });
  window.addEventListener('orientationchange', scheduleCompute, { passive: true });

  document.addEventListener('click', (e) => {
    const t = e.target;
    if (t instanceof Element && t.closest('[data-origin-anchor],[data-expand],[data-open]')) {
      setOriginFromEvent(e);
    }
  }, { capture: true });

  function initOrigin() { computeOriginFromViewport(); }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initOrigin);
  } else {
    initOrigin();
  }
  document.addEventListener('astro:after-swap', initOrigin);
</script>