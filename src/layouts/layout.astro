---
import { ClientRouter } from 'astro:transitions';
import BottomBar from '../components/BottomBar.astro';
import Footer from '../layouts/Footer.astro';
import '../styles/global.css';

export interface Props {
  name?: string;
  title?: string;
}
const { name, title } = Astro.props as Props;
---

<html lang='en'>
  <head>
    <ClientRouter fallback={'none'} transition:animate={'none'} />

    <meta charset='utf-8' />
    <link rel='icon' type='image/svg+xml' href='/favicon.svg' />
    <meta name='viewport' content='width=device-width' />
    <meta name='generator' content={Astro.generator} />
    <title>{title ? title : name ? `${name} | Astro` : 'Astro'}</title>

    <link rel='preconnect' href='https://fonts.googleapis.com' />
    <link rel='preconnect' href='https://fonts.gstatic.com' crossorigin />

    <style is:global>
      html {
        overflow-x: hidden;
        /* Default transition durations */
        --transition-duration: 800ms;
        --transition-timing: cubic-bezier(0.4, 0, 0.2, 1);
      }
      html.no-scroll {
        padding-right: var(--sbw, 0px);
      }

      /* Faster transitions on mobile */
      @media (max-width: 768px) {
        html {
          --transition-duration: 400ms;
        }
      }

      /* Page transition loading state */
      body.page-transitioning {
        pointer-events: none;
      }

      body.page-transitioning::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          90deg,
          transparent,
          var(--primary, #007acc) 50%,
          transparent
        );
        animation: loading-bar 1.5s ease-in-out infinite;
        z-index: 9999;
      }

      @keyframes loading-bar {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100vw);
        }
      }

      .page-container {
        position: relative;
        width: 100%;
        min-height: 100vh;
      }

      .page-container {
        --blur-p: 0;
        --blr-m: var(--grid-margin);
        --blr-s: 0.032; /* fallback, will be calculated via JS */
        position: relative;
        z-index: 1;
        will-change: transform;
        transform-origin: var(--origin-x, 50%) var(--origin-y, 50%);
        transition-duration: var(--MENU_DURATION);
        transition-property: transform, opacity;
        transition-timing-function: linear;
        /* transition-timing-function: linear; */
      }

      @media (max-width: 743px) {
        .page-container {
          --blr-m: 10px;
        }
      }

      .page-container .page-content {
        will-change: transform;
        transform-origin: var(--origin-x, 50%) var(--origin-y, 50%);
        transition-duration: var(--MENU_DURATION, 0.2s);
        transition-property: transform, opacity;
        transition-timing-function: linear;
      }

      /* ====== Manual transition (no Astro VT) ====== */

      /* Ghost (old page snapshot) is appended directly to <body> */
      .ghost-page {
        position: fixed;
        overflow: clip;
        pointer-events: none;
        will-change: transform, opacity;
        background: var(--background);
      }

      /* OLD page (ghost) leave — your slide-out-down equivalent */
      .ghost-leave {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
      .ghost-leave-active {
        transition:
          transform var(--transition-duration, 800ms)
            var(--transition-timing, cubic-bezier(0.4, 0, 0.2, 1)),
          opacity var(--transition-duration, 800ms) linear;
        transform: translate(--origin-x, --origin-y) rotate(1deg) scale(0.95);
        opacity: 0.3;
      }

      /* NEW page enter — your slide-in-bottom */
      .page-enter {
        transform: translateY(115%);
        opacity: 1;
      }
      .page-enter-active {
        transition: transform var(--transition-duration, 800ms)
          var(--transition-timing, cubic-bezier(0.4, 0, 0.2, 1));
        transform: translateY(0%);
      }

      /* Faster transitions on mobile */
      @media (max-width: 768px) {
        .ghost-leave-active {
          transition:
            transform 400ms
              var(--transition-timing, cubic-bezier(0.4, 0, 0.2, 1)),
            opacity 400ms linear;
        }
        .page-enter-active {
          transition: transform 400ms
            var(--transition-timing, cubic-bezier(0.4, 0, 0.2, 1));
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .ghost-leave,
        .page-enter {
          transform: none !important;
          opacity: 1 !important;
        }
        .ghost-leave-active,
        .page-enter-active {
          transition: none !important;
        }
      }

      /* Keep element-level niceties */
      .page-content * {
        transition-property: transform, opacity, scale;
        transition-timing-function: var(--transition-timing);
      }

      .page-container[data-blurred='true'] .page-content {
        transform: scale(calc(1 - (var(--blr-s) * var(--blur-p))));
        transition: none !important;
      }

      .page-container [data-blur-mask] > div {
        position: sticky;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
      }
      .page-container [data-blur-mask] > div > div:first-child:before {
        left: 0;
        transform-origin: left;
      }
      .page-container [data-blur-mask] > div > div:first-child:after {
        right: 0;
        transform-origin: right;
      }
      .page-container [data-blur-mask] > div > div:after,
      .page-container [data-blur-mask] > div > div:before {
        content: '';
        position: absolute;
        background-color: #000;
        will-change: transform;
      }
      .page-container [data-blur-mask] > div > div:first-child:after,
      .page-container [data-blur-mask] > div > div:first-child:before {
        width: var(--blr-m);
        height: 100%;
        top: 0;
        transform: scaleX(var(--blur-p));
      }
      .page-container [data-blur-mask] > div > div:nth-child(2):before {
        top: 0;
        transform-origin: top;
      }

      #old-page [data-blur-mask] > div > div:nth-child(2):after {
        width: 100%;
        height: 10000px;
        top: -10000px;
        background-color: black;
        transform-origin: bottom;
      }

      /* .page-container [data-blur-mask]>div>div:nth-child(2):after, */
      .page-container [data-blur-mask] > div > div:nth-child(2):before {
        width: 100%;
        height: var(--blr-m);
        left: 0;
        transform: scaleY(var(--blur-p));
      }

      .page-container [data-blur-mask] > div > div:nth-child(3):before {
        left: var(--blr-m);
        border-top-left-radius: 20px;
        transform-origin: 0% 0%;
        transform: translate(
            calc((var(--blur-p) - 1) * var(--blr-m)),
            calc((var(--blur-p) - 1) * var(--blr-m))
          )
          scale(var(--blur-p));
      }

      .page-container [data-blur-mask] > div > div:nth-child(3):after {
        right: var(--blr-m);
        border-top-right-radius: 20px;
        transform-origin: 100% 0%;
        transform: translate(
            calc(-1 * (var(--blur-p) - 1) * var(--blr-m)),
            calc((var(--blur-p) - 1) * var(--blr-m))
          )
          scale(var(--blur-p));
      }

      .page-container [data-blur-mask] > div > div:nth-child(3):after,
      .page-container [data-blur-mask] > div > div:nth-child(3):before {
        top: var(--blr-m);
        width: var(--page-border-radius);
        height: calc(2 * var(--page-border-radius));
        box-shadow: 0 calc(-1 * var(--page-border-radius)) 0 0 #000;
        background-color: rgba(0, 0, 0, 0);
      }

      .page-container[data-blurred='true'] #bottom-bar-overlay::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 0;
        width: 100%;
        height: 40px;
        background: inherit;
      }

      .page-container[data-blurred='true'] #bottom-bar-overlay::before {
        content: '';
        position: absolute;
        bottom: 100%;
        left: 0;
        width: 100%;
        height: 40px;
        background: inherit;
      }

      .footer-pin-wrapper {
        position: relative !important;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        /* min-height: 100vh; */
        overflow: hidden;
      }

      .page-container[data-blurred='true'] #footer::after {
        position: absolute;
        overflow: hidden;
        top: 100%;
        content: '';
        width: 100%;
        height: 200px;
        background-color: inherit;
        z-index: -1;
      }
    </style>
  </head>

  <body class='bg-black'>
    <!-- Bottom bar overlay - part of each page for view transitions -->

    <!-- Persistent chrome -->
    <BottomBar transition:persist transition:animate='none' />
    <div
      id='ghost-layer'
      transition:persist
      style='position:fixed; inset:0; pointer-events:none; '
    >
    </div>
    <div
      data-slug={name}
      class='page-container bg-background relative h-full max-w-[var(--100vw)]'
      id='page'
    >
      <div class='page-content'>
        <div
          id='bottom-bar-overlay'
          class='fixed inset-0 pointer-events-none backdrop-blur-[0px] bg-black/40 will-change-[opacity] z-[5]'
          style='opacity: 0;'
        >
        </div>
        <slot />
        <Footer />
      </div>

      <div
        data-blur-mask
        inert
        aria-hidden='true'
        class='absolute w-full h-full top-0 left-0 pointer-events-none'
      >
        <div>
          <div id='#overlay-left-right'></div>
          <div id='#overlay-top'></div>
          <div id='#overlay-corner'></div>
        </div>
        <span></span>
      </div>
    </div>

    <script>
      import { gsap } from 'gsap';

      // Faster transitions on mobile for better performance
      const isMobile = window.innerWidth <= 768;
      const DURATION = isMobile ? 0.35 : 0.5,
        EASE = 'power2.out';
      const prefersReduced = matchMedia(
        '(prefers-reduced-motion: reduce)'
      ).matches;
      const ghostLayer = document.getElementById('ghost-layer');

      function stageOldPageLeave(pageEl: HTMLElement | null): void {
        if (!pageEl || !ghostLayer) return;
        pageEl.id = 'old-page';
        const rect = pageEl.getBoundingClientRect();
        const ghost = pageEl.cloneNode(true) as HTMLElement;

        ghost.classList.add('ghost-page');
        Object.assign(ghost.style, {
          position: 'fixed',
          top: rect.top + 'px',
          left: rect.left + 'px',
          width: rect.width + 'px',
          height: rect.height + 'px',
          transform: 'none',
          opacity: '1',
          pointerEvents: 'none',
        });

        // clear previous ghosts
        ghostLayer.querySelectorAll('.ghost-page').forEach((el) => {
          gsap.killTweensOf(el);
          el.remove();
        });
        ghostLayer.appendChild(ghost);

        if (prefersReduced) return;

        requestAnimationFrame(() => {
          gsap.to(ghost, {
            duration: DURATION * 1.2,
            ease: EASE,
            yPercent: isMobile ? 0 : 6,
            xPercent: isMobile ? 0 : -3,
            rotate: isMobile ? 0 : -1.5,
            scale: isMobile ? 0.9 : 0.8,
            autoAlpha: 0,
            delay: 0.4,
            transformOrigin: (i, el) =>
              getComputedStyle(el).getPropertyValue('--origin-x') +
              ' ' +
              getComputedStyle(el).getPropertyValue('--origin-y'),
            onComplete: () => ghost.remove(),
          });
        });
      }

      function animateNewPageEnter(): void {
        if (prefersReduced) return;
        const page = document.getElementById('page');
        if (!page) return;

        gsap.killTweensOf(page);

        const prevTransition = page.style.transition;
        page.style.transition = 'none';

        page.offsetHeight;

        gsap.set(page, { yPercent: 115 });

        // 4) Next frame: restore CSS transition (optional) and run the GSAP tween
        requestAnimationFrame(() => {
          page.style.transition = prevTransition; // or '' to clear
          gsap.to(page, {
            yPercent: 0,
            duration: DURATION,
            ease: EASE,
            clearProps: 'transform',
          });
        });
      }

      // Hook the Astro lifecycle
      document.addEventListener('astro:before-preparation', () => {
        const current = document.getElementById('page');
        stageOldPageLeave(current);
      });

      document.addEventListener('astro:after-swap', () => {
        animateNewPageEnter();
      });
    </script>
  </body>
</html>

<script>
  const sbw = () => window.innerWidth - document.documentElement.clientWidth;
  document.documentElement.style.setProperty('--sbw', sbw() + 'px');
  addEventListener('resize', () =>
    document.documentElement.style.setProperty('--sbw', sbw() + 'px')
  );
</script>

<script>
  import Lenis from 'lenis';
  (function () {
    if (!(window as any).__lenis)
      (window as any).__lenis = new Lenis({ autoRaf: true });
    const lenis = (window as any).__lenis;

    document.addEventListener('astro:before-preparation', () => {
      if (lenis && typeof lenis.stop === 'function') lenis.stop();
    });
    document.addEventListener('astro:after-swap', () => {
      if (lenis && typeof lenis.start === 'function') lenis.start();
    });
  })();
</script>

<script>
  /* @ts-nocheck */

  // Global type declarations
  declare global {
    interface Window {
      __bottomBarExpanded?: boolean;
      __setScaleOrigin?: (xPct?: number, yPct?: number) => void;
      __lenis?: {
        stop?: () => void;
        start?: () => void;
      };
    }
  }

  function getPageEl(): HTMLElement | null {
    return document.getElementById('page');
  }
  const EDGE_PAD_PCT = 4;
  const lerp = (a: number, b: number, t: number): number => a + (b - a) * t;
  const clamp = (v: number, lo: number, hi: number): number =>
    Math.min(hi, Math.max(lo, v));
  function computeOriginFromViewport(edgePadPct: number = EDGE_PAD_PCT): void {
    // Don't update origin if expanded content is appearing
    if (window.__bottomBarExpanded) return;

    const page = getPageEl();
    if (!page) return;
    const rect = page.getBoundingClientRect();
    const pageTopAbs = rect.top + window.scrollY;
    const pageHeight = Math.max(page.scrollHeight, page.clientHeight);
    const viewportH = window.innerHeight;
    const scrollable = Math.max(pageHeight - viewportH, 0);
    const scrollInPage = Math.min(
      scrollable,
      Math.max(0, window.scrollY - pageTopAbs)
    );
    const p = scrollable > 0 ? scrollInPage / scrollable : 0.5;
    const yPct = lerp(edgePadPct, 100 - edgePadPct, p);
    page.style.setProperty('--origin-x', '50%');
    page.style.setProperty('--origin-y', `${yPct}%`);
  }

  function setOriginFromEvent(e: MouseEvent): void {
    // Don't update origin if expanded content is appearing
    if (window.__bottomBarExpanded) return;

    const page = getPageEl();
    if (!page || !e) return;
    const rect = page.getBoundingClientRect();
    const xWithin = e.clientX - rect.left;
    const yWithin = e.clientY - rect.top;
    const xPct = (xWithin / rect.width) * 100;
    const h = Math.max(page.scrollHeight, page.clientHeight);
    const yPct =
      ((yWithin + window.scrollY - (rect.top + window.scrollY)) / h) * 100;
    page.style.setProperty(
      '--origin-x',
      `${Math.min(100, Math.max(0, xPct))}%`
    );
    page.style.setProperty(
      '--origin-y',
      `${Math.min(100, Math.max(0, yPct))}%`
    );
  }

  window.__setScaleOrigin = function (xPct?: number, yPct?: number): void {
    const page = getPageEl();
    if (!page) return;
    if (typeof xPct === 'number')
      page.style.setProperty(
        '--origin-x',
        `${Math.min(100, Math.max(0, xPct))}%`
      );
    if (typeof yPct === 'number')
      page.style.setProperty(
        '--origin-y',
        `${Math.min(100, Math.max(0, yPct))}%`
      );
  };

  let rafId: number | null = null;
  function scheduleCompute(): void {
    if (rafId !== null) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => {
      computeOriginFromViewport();
      rafId = null;
    });
  }
  window.addEventListener('scroll', scheduleCompute, { passive: true });
  window.addEventListener('resize', scheduleCompute, { passive: true });
  window.addEventListener('orientationchange', scheduleCompute, {
    passive: true,
  });

  document.addEventListener(
    'click',
    (e) => {
      const t = e.target;
      if (
        t instanceof Element &&
        t.closest('[data-origin-anchor],[data-expand],[data-open]')
      ) {
        setOriginFromEvent(e);
      }
    },
    { capture: true }
  );

  function initOrigin(): void {
    computeOriginFromViewport();
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initOrigin);
  } else {
    initOrigin();
  }
  document.addEventListener('astro:after-swap', initOrigin);

  // Calculate perfect blur scale based on viewport and margin
  function updateBlurScale(): void {
    const page = getPageEl();
    if (!page) return;

    // Calculate scrollbar width
    const scrollbarWidth =
      window.innerWidth - document.documentElement.clientWidth;
    const vw100 = window.innerWidth - scrollbarWidth;

    // Calculate grid margin using the same formula from global.css
    // --grid-margin: clamp(8px, 4.412px + var(--100vw) * 0.0092, 20px);
    const gridMarginMin = 8;
    const gridMarginMax = 16;
    const gridMarginCalculated = 4.412 + vw100 * 0.0092;
    const gridMargin = Math.max(
      gridMarginMin,
      Math.min(gridMarginMax, gridMarginCalculated)
    );

    // For small screens, use 10px as per the media query
    const finalBlrM = vw100 <= 743 ? 10 : gridMargin;

    // Calculate the scale factor: (viewport - 2*margin) / viewport
    // This gives us the exact scale needed to fit content within the unmasked area
    const blrS = vw100 > 0 && finalBlrM > 0 ? (2 * finalBlrM) / vw100 : 0;

    page.style.setProperty('--blr-s', blrS.toString());
  }

  // Update blur scale on resize
  window.addEventListener('resize', updateBlurScale, { passive: true });
  window.addEventListener('orientationchange', updateBlurScale, {
    passive: true,
  });

  // Initialize blur scale
  function initBlurScale(): void {
    // Use requestAnimationFrame for immediate but deferred execution
    requestAnimationFrame(() => {
      updateBlurScale();
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initBlurScale);
  } else {
    initBlurScale();
  }
  document.addEventListener('astro:after-swap', initBlurScale);
</script>

<script>
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  function initFooterPin(): void {
    const footer = document.getElementById('footer');

    if (!footer) return;
    // Reset transforms before applying the pin animation
    gsap.killTweensOf(footer);
    gsap.set(footer, { clearProps: 'transform,opacity' });

    gsap.fromTo(
      footer,
      { y: -350, ease: 'none', immediateRender: false },
      {
        y: 0,
        ease: 'none',
        immediateRender: false,
        scrollTrigger: {
          trigger: footer,
          start: 'top bottom',
          end: 'bottom bottom',
          scrub: true,
          invalidateOnRefresh: true,
          // markers: true,
        },
      }
    );

    // Refresh ScrollTrigger after setup
    ScrollTrigger.refresh();
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFooterPin);
  } else {
    setTimeout(() => {
      // Delay to ensure DOM is fully ready
      initFooterPin();
    }, 2000);
    initFooterPin();
  }

  // Reinitialize after Astro page transitions
  document.addEventListener('astro:after-swap', () => {
    // Small delay to ensure DOM updates settle before re-initialising
    setTimeout(initFooterPin, 2000);
  });

  // Debounced refresh function to prevent excessive calls
  let refreshTimeout: ReturnType<typeof setTimeout> | null = null;
  let isRefreshing = false; // Prevent recursive calls

  function debounceRefresh(delay: number = 100): void {
    if (isRefreshing || refreshTimeout !== null) return;

    refreshTimeout = setTimeout(() => {
      isRefreshing = true;
      ScrollTrigger.refresh();
      refreshTimeout = null;
      // Reset flag after a short delay to allow legitimate refreshes
      setTimeout(() => {
        isRefreshing = false;
      }, 100);
    }, delay);
  }

  // Handle window resize
  window.addEventListener('resize', () => {
    debounceRefresh(150);
  });

  // Cross-page communication for ScrollTrigger refresh
  // Listen for custom events from page-specific animations
  document.addEventListener('refreshScrollTrigger', (e: any) => {
    console.log(
      'Received refresh request from:',
      e.detail?.source || 'unknown'
    );
    debounceRefresh(e.detail?.delay || 100);
  });

  // Global function to manually refresh ScrollTrigger (for programmatic changes)
  (window as any).__refreshScrollTrigger = debounceRefresh;

  // Test function - you can call this in console to verify it works
  (window as any).__testScrollTriggerRefresh = () => {
    console.log('Manual ScrollTrigger refresh triggered');
    debounceRefresh(0);
  };
</script>
